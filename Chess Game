board = [
    ["b_rook", "b_knight", "b_bishop", "b_queen", "b_king", "b_bishop", "b_knight", "b_rook"],
    ["b_pawn"] * 8, [""] * 8, [""] * 8, [""] * 8, [""] * 8, ["w_pawn"] * 8,
    ["w_rook", "w_knight", "w_bishop", "w_queen", "w_king", "w_bishop", "w_knight", "w_rook"],
]
piece_symbols = {
    "b_pawn": "♟", "b_rook": "♜", "b_knight": "♞", "b_bishop": "♝", "b_queen": "♛", "b_king": "♚",
    "w_pawn": "♙", "w_rook": "♖", "w_knight": "♘", "w_bishop": "♗", "w_queen": "♕", "w_king": "♔"
}
def algebraic_to_index(pos):
    # Added error check for invalid input length
    if len(pos) != 2 or not ('a' <= pos[0] <= 'h') or not ('1' <= pos[1] <= '8'):
        raise ValueError("Invalid algebraic notation format or out of bounds.")
    col = ord(pos[0].lower()) - ord('a')
    row = 8 - int(pos[1])
    return row, col

def is_path_clear(board, src_row, src_col, dst_row, dst_col):
    # This function is correct.
    row_diff = dst_row - src_row
    col_diff = dst_col - src_col
    row_step = 0
    if row_diff != 0: row_step = row_diff // abs(row_diff)
    col_step = 0
    if col_diff != 0: col_step = col_diff // abs(col_diff)

    current_row, current_col = src_row + row_step, src_col + col_step
    
    while (current_row, current_col) != (dst_row, dst_col):
        if board[current_row][current_col] != "": return False
        current_row += row_step
        current_col += col_step
    return True

def is_valid_rook_move(board, src_row, src_col, dst_row, dst_col):
    is_horizontal = src_row == dst_row
    is_vertical = src_col == dst_col
    if not (is_horizontal or is_vertical): return False
    return is_path_clear(board, src_row, src_col, dst_row, dst_col)

def is_valid_knight_move(src_row, src_col, dst_row, dst_col):
    d_row = abs(dst_row - src_row)
    d_col = abs(dst_col - src_col)
    return d_row * d_col == 2

def is_valid_bishop_move(board, src_row, src_col, dst_row, dst_col):
    if abs(dst_row - src_row) != abs(dst_col - src_col): return False
    return is_path_clear(board, src_row, src_col, dst_row, dst_col)

def is_valid_queen_move(board, src_row, src_col, dst_row, dst_col):
    return is_valid_rook_move(board, src_row, src_col, dst_row, dst_col) or \
           is_valid_bishop_move(board, src_row, src_col, dst_row, dst_col)

def is_valid_king_move(src_row, src_col, dst_row, dst_col):
    d_row = abs(dst_row - src_row)
    d_col = abs(dst_col - src_col)
    return max(d_row, d_col) == 1

def is_valid_pawn_move(piece, src_row, src_col, dst_row, dst_col, board):
    # This function is correct.
    color = piece[0]
    direction = -1 if color == "w" else 1
    start_row = 6 if color == "w" else 1
    
    # Diagonal Capture
    if dst_row == src_row + direction and (dst_col == src_col - 1 or dst_col == src_col + 1):
        target_piece = board[dst_row][dst_col]
        return target_piece != "" and not target_piece.startswith(color)
        
    # Forward Movement (must be to an empty square)
    if board[dst_row][dst_col] == "":
        if dst_col == src_col and dst_row == src_row + direction: return True # One square
        if dst_col == src_col and src_row == start_row and dst_row == src_row + 2 * direction:
            return board[src_row + direction][src_col] == "" # Two squares, path clear
    return False

def is_move_valid_for_piece(piece, board, src_row, src_col, dst_row, dst_col):
    piece_type = piece.split('_')[1]
    if piece_type == "pawn": return is_valid_pawn_move(piece, src_row, src_col, dst_row, dst_col, board)
    elif piece_type == "rook": return is_valid_rook_move(board, src_row, src_col, dst_row, dst_col)
    elif piece_type == "knight": return is_valid_knight_move(src_row, src_col, dst_row, dst_col)
    elif piece_type == "bishop": return is_valid_bishop_move(board, src_row, src_col, dst_row, dst_col)
    elif piece_type == "queen": return is_valid_queen_move(board, src_row, src_col, dst_row, dst_col)
    elif piece_type == "king": return is_valid_king_move(src_row, src_col, dst_row, dst_col)
    return False

# --- CHECK/CHECKMATE LOGIC ---
def find_king(board, color):
    for r in range(8):
        for c in range(8):
            if board[r][c] == f"{color}_king": return r, c
    return None, None

def is_in_check(board, color):
    king_row, king_col = find_king(board, color)
    if king_row is None: return False
    
    opponent_color = "b" if color == "w" else "w"
    for r in range(8):
        for c in range(8):
            piece = board[r][c]
            if piece.startswith(opponent_color):
                # Check if this opponent piece can attack the king's square
                if is_move_valid_for_piece(piece, board, r, c, king_row, king_col):
                    return True
    return False

def simulate_move(board, src_r, src_c, dst_r, dst_c):
    new_board = [row[:] for row in board] # Deep copy
    piece_to_move = new_board[src_r][src_c]
    new_board[dst_r][dst_c] = piece_to_move
    new_board[src_r][src_c] = ""
    return new_board

def get_all_legal_moves(board, color):
    """Generates all legal moves for a given color, including check evasion."""
    legal_moves = []
    for r_start in range(8):
        for c_start in range(8):
            piece = board[r_start][c_start]
            if piece.startswith(color):
                for r_end in range(8):
                    for c_end in range(8):
                        target_piece = board[r_end][c_end]
                        if target_piece.startswith(color): continue # Can't capture own
                        
                        if is_move_valid_for_piece(piece, board, r_start, c_start, r_end, c_end):
                            # Test if the move leaves the king in check
                            temp_board = simulate_move(board, r_start, c_start, r_end, c_end)
                            if not is_in_check(temp_board, color):
                                legal_moves.append(((r_start, c_start), (r_end, c_end)))
    return legal_moves

# --- MAIN MOVE EXECUTION (Modified) ---
def make_move(board, move, current_turn):
    try:
        src, dst = move.strip().split()
        src_row, src_col = algebraic_to_index(src)
        dst_row, dst_col = algebraic_to_index(dst)
    except Exception as e:
        print(f"Error: Invalid move format or position. {e}")
        return False
        
    # Check 1: Is the move even in the list of legal, non-checking moves?
    legal_moves = get_all_legal_moves(board, current_turn)
    move_indices = ((src_row, src_col), (dst_row, dst_col))

    if move_indices not in legal_moves:
        # Provide better error feedback
        piece = board[src_row][src_col]
        if piece == "":
            print(f"Error: No piece at {src}.")
        elif not piece.startswith(current_turn):
            print(f"Error: That's not your piece.")
        elif board[dst_row][dst_col].startswith(current_turn):
            print("Error: You can't capture your own piece.")
        elif is_in_check(simulate_move(board, src_row, src_col, dst_row, dst_col), current_turn):
             print("Illegal move: This move leaves your King in check!")
        else:
             print("Error: Invalid move for that piece (check rules/path/movement).")
        return False
        
    # If the move is in the legal list, execute it
    board[dst_row][dst_col] = board[src_row][src_col]
    board[src_row][src_col] = ""
    
    piece_moved = board[dst_row][dst_col]
    if piece_moved.endswith("pawn") and (dst_row == 0 or dst_row == 7):
        board[dst_row][dst_col] = f"{current_turn}_queen"
        print("Pawn promoted to Queen! ♕")
        
    return True

def print_board(board):
    print("\n    a   b   c   d   e   f   g   h")
    print("  +---+---+---+---+---+---+---+---+")
    for i, row in enumerate(board):
        print(f"{8 - i} | {' | '.join(piece_symbols.get(p, ' ') for p in row)} |")
        print("  +---+---+---+---+---+---+---+---+")

current_turn = "w"
while True:
    print_board(board)
    opponent_turn = "b" if current_turn == "w" else "w"
    
    # Check for game over conditions
    legal_moves = get_all_legal_moves(board, current_turn)
    if not legal_moves:
        if is_in_check(board, current_turn):
            print(f"*** CHECKMATE! {opponent_turn.upper()} wins! ***")
        else:
            print("*** STALEMATE! It's a draw. ***")
        break
        
    if is_in_check(board, current_turn):
        print("\n*** You are in CHECK! ***")
        
    print(f"\nIt's {current_turn.upper()}'s turn.")
    move = input("Enter your move (e.g., e2 e4) or 'exit' to quit: ").strip()
    
    if move.lower() == "exit":
        print("Thanks for playing!")
        break
        
    if make_move(board, move, current_turn):
        current_turn = opponent_turn
