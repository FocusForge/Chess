board = [
    ["b_rook", "b_knight", "b_bishop", "b_queen", "b_king", "b_bishop", "b_knight", "b_rook"],
    ["b_pawn"] * 8, [""] * 8, [""] * 8, [""] * 8, [""] * 8, ["w_pawn"] * 8,
    ["w_rook", "w_knight", "w_bishop", "w_queen", "w_king", "w_bishop", "w_knight", "w_rook"],
]
piece_symbols = {
    "b_pawn": "♟", "b_rook": "♜", "b_knight": "♞", "b_bishop": "♝", "b_queen": "♛", "b_king": "♚",
    "w_pawn": "♙", "w_rook": "♖", "w_knight": "♘", "w_bishop": "♗", "w_queen": "♕", "w_king": "♔"
}
# --- NEW GLOBAL VARIABLE FOR CASTLING STATE ---
has_moved = {
    "w_king": False, "b_king": False,
    "w_rook_ks": False, "w_rook_qs": False, # Kingside (h-file) and Queenside (a-file) Rooks
    "b_rook_ks": False, "b_rook_qs": False,
}
# ---------------------------------------------

def algebraic_to_index(pos):
    # Added error check for invalid input length
    if len(pos) != 2 or not ('a' <= pos[0] <= 'h') or not ('1' <= pos[1] <= '8'):
        raise ValueError("Invalid algebraic notation format or out of bounds.")
    col = ord(pos[0].lower()) - ord('a')
    row = 8 - int(pos[1])
    return row, col

def is_path_clear(board, src_row, src_col, dst_row, dst_col):
    row_diff = dst_row - src_row
    col_diff = dst_col - src_col
    row_step = 0
    if row_diff != 0: row_step = row_diff // abs(row_diff)
    col_step = 0
    if col_diff != 0: col_step = col_diff // abs(col_diff)

    current_row, current_col = src_row + row_step, src_col + col_step
    
    while (current_row, current_col) != (dst_row, dst_col):
        if board[current_row][current_col] != "": return False
        current_row += row_step
        current_col += col_step
    return True

def is_valid_rook_move(board, src_row, src_col, dst_row, dst_col):
    is_horizontal = src_row == dst_row
    is_vertical = src_col == dst_col
    if not (is_horizontal or is_vertical): return False
    return is_path_clear(board, src_row, src_col, dst_row, dst_col)

def is_valid_knight_move(src_row, src_col, dst_row, dst_col):
    d_row = abs(dst_row - src_row)
    d_col = abs(dst_col - src_col)
    return d_row * d_col == 2

def is_valid_bishop_move(board, src_row, src_col, dst_row, dst_col):
    if abs(dst_row - src_row) != abs(dst_col - src_col): return False
    return is_path_clear(board, src_row, src_col, dst_row, dst_col)

def is_valid_queen_move(board, src_row, src_col, dst_row, dst_col):
    return is_valid_rook_move(board, src_row, src_col, dst_row, dst_col) or \
           is_valid_bishop_move(board, src_row, src_col, dst_row, dst_col)

def is_valid_king_move(src_row, src_col, dst_row, dst_col):
    d_row = abs(dst_row - src_row)
    d_col = abs(dst_col - src_col)
    # Allows King to move 1 square OR 2 squares horizontally for castling detection later
    return max(d_row, d_col) == 1 or (d_row == 0 and d_col == 2) 

def is_valid_pawn_move(piece, src_row, src_col, dst_row, dst_col, board):
    color = piece[0]
    direction = -1 if color == "w" else 1
    start_row = 6 if color == "w" else 1
    
    # Diagonal Capture
    if dst_row == src_row + direction and (dst_col == src_col - 1 or dst_col == src_col + 1):
        target_piece = board[dst_row][dst_col]
        # NOTE: Missing En Passant check here, but standard capture is correct
        return target_piece != "" and not target_piece.startswith(color)
        
    # Forward Movement (must be to an empty square)
    if board[dst_row][dst_col] == "":
        if dst_col == src_col and dst_row == src_row + direction: return True # One square
        if dst_col == src_col and src_row == start_row and dst_row == src_row + 2 * direction:
            return board[src_row + direction][src_col] == "" # Two squares, path clear
    return False

def is_move_valid_for_piece(piece, board, src_row, src_col, dst_row, dst_col):
    piece_type = piece.split('_')[1]
    
    # Check if destination is occupied by own color (Skip this check for King/Castling validation)
    target_piece = board[dst_row][dst_col]
    if target_piece.startswith(piece[0]):
        return False
        
    if piece_type == "pawn": return is_valid_pawn_move(piece, src_row, src_col, dst_row, dst_col, board)
    elif piece_type == "rook": return is_valid_rook_move(board, src_row, src_col, dst_row, dst_col)
    elif piece_type == "knight": return is_valid_knight_move(src_row, src_col, dst_row, dst_col)
    elif piece_type == "bishop": return is_valid_bishop_move(board, src_row, src_col, dst_row, dst_col)
    elif piece_type == "queen": return is_valid_queen_move(board, src_row, src_col, dst_row, dst_col)
    elif piece_type == "king": 
        # For King moves, we only validate 1 square movement here, Castling is validated separately
        d_row = abs(dst_row - src_row)
        d_col = abs(dst_col - src_col)
        return max(d_row, d_col) == 1

    return False

# --- NEW CASTLING VALIDATION FUNCTION ---
def is_square_attacked(board, row, col, attacker_color):
    """Checks if a given square is attacked by the specified color."""
    for r_opp in range(8):
        for c_opp in range(8):
            piece = board[r_opp][c_opp]
            if piece.startswith(attacker_color):
                # Temporarily check if the opponent's piece *can* move to the square, 
                # ignoring whether that move would check *their* own king.
                # Use the piece's base movement function, skipping the 'check-rule' loop in get_all_legal_moves.
                
                # Check 1: Is the target square occupied by an opponent piece? (is_move_valid_for_piece already checks this)
                target_piece = board[row][col]
                if target_piece.startswith(attacker_color):
                    continue # Attacker piece is on its own color, can't move there (this is crude, but necessary simplification)
                
                # Create a temporary board to run the validation check cleanly
                temp_board = [r[:] for r in board]
                temp_board[row][col] = "" # Ensure the target square is treated as empty for path checks if a friendly piece is there
                
                if is_move_valid_for_piece(piece, temp_board, r_opp, c_opp, row, col):
                    return True
    return False

def is_valid_castle(board, color, is_kingside):
    king_row = 7 if color == "w" else 0
    opponent_color = "b" if color == "w" else "w"
    
    # 1. Check if King and Rook have moved
    king_key = f"{color}_king"
    rook_key = f"{color}_rook_ks" if is_kingside else f"{color}_rook_qs"
    
    if has_moved[king_key] or has_moved[rook_key]:
        return False
    if board[king_row][4] != f"{color}_king":
        return False # King must be on original square

    # Define coordinates and squares to check
    if is_kingside:
        empty_cols = [5, 6]
        attacked_cols = [4, 5, 6] # e-file (king's starting pos), f-file (pass through), g-file (land)
        rook_col = 7
    else: # Queenside
        empty_cols = [1, 2, 3] # Note: b-file, c-file, d-file must be empty
        attacked_cols = [4, 3, 2] # e-file (start), d-file (pass), c-file (land)
        rook_col = 0
        
    # 2. Check if path is clear (squares between King and Rook are empty)
    for col in empty_cols:
        if board[king_row][col] != "":
            return False

    # 3. Check if King is in check, or passes through/lands on an attacked square
    for col in attacked_cols:
        if is_square_attacked(board, king_row, col, opponent_color):
            return False

    return True
# ---------------------------------------------


# --- CHECK/CHECKMATE LOGIC ---
def find_king(board, color):
    for r in range(8):
        for c in range(8):
            if board[r][c] == f"{color}_king": return r, c
    return None, None

def is_in_check(board, color):
    king_row, king_col = find_king(board, color)
    if king_row is None: return False
    
    opponent_color = "b" if color == "w" else "w"
    
    # Reusing the new is_square_attacked function for simpler check logic
    return is_square_attacked(board, king_row, king_col, opponent_color)


def simulate_move(board, src_r, src_c, dst_r, dst_c):
    new_board = [row[:] for row in board] # Deep copy
    piece_to_move = new_board[src_r][src_c]
    new_board[dst_r][dst_c] = piece_to_move
    new_board[src_r][src_c] = ""
    return new_board

def get_all_legal_moves(board, color):
    """Generates all legal moves for a given color, including check evasion and castling."""
    legal_moves = []
    king_row = 7 if color == "w" else 0
    
    # --- ADD CASTLING MOVES ---
    # Kingside Castling: e1 g1 (or e8 g8)
    if is_valid_castle(board, color, True):
        legal_moves.append(((king_row, 4), (king_row, 6)))
    # Queenside Castling: e1 c1 (or e8 c8)
    if is_valid_castle(board, color, False):
        legal_moves.append(((king_row, 4), (king_row, 2)))
    # --------------------------
    
    for r_start in range(8):
        for c_start in range(8):
            piece = board[r_start][c_start]
            if piece.startswith(color):
                for r_end in range(8):
                    for c_end in range(8):
                        target_piece = board[r_end][c_end]
                        if target_piece.startswith(color): continue # Can't capture own
                        
                        # Use the simplified King movement for general checks (max(d_row, d_col) == 1)
                        if piece.endswith("king"):
                            if abs(r_end - r_start) > 1 or abs(c_end - c_start) > 1:
                                continue # Filter out 2-square King moves here (handled by castling above)

                        if is_move_valid_for_piece(piece, board, r_start, c_start, r_end, c_end):
                            # Test if the move leaves the king in check
                            temp_board = simulate_move(board, r_start, c_start, r_end, c_end)
                            if not is_in_check(temp_board, color):
                                legal_moves.append(((r_start, c_start), (r_end, c_end)))
    return legal_moves

# --- MAIN MOVE EXECUTION (UPDATED) ---
def make_move(board, move, current_turn):
    try:
        src, dst = move.strip().split()
        src_row, src_col = algebraic_to_index(src)
        dst_row, dst_col = algebraic_to_index(dst)
    except Exception as e:
        print(f"Error: Invalid move format or position. {e}")
        return False
        
    piece_to_move = board[src_row][src_col]
        
    # Check 1: Is the move even in the list of legal, non-checking moves?
    legal_moves = get_all_legal_moves(board, current_turn)
    move_indices = ((src_row, src_col), (dst_row, dst_col))

    if move_indices not in legal_moves:
        # Provide better error feedback
        if piece_to_move == "":
            print(f"Error: No piece at {src}.")
        elif not piece_to_move.startswith(current_turn):
            print(f"Error: That's not your piece.")
        elif board[dst_row][dst_col].startswith(current_turn):
            print("Error: You can't capture your own piece.")
        else:
            print("Error: Invalid move (check rules/path, or this move leaves your King in check!).")
        return False
        
    # --- CASTLING EXECUTION ---
    if piece_to_move.endswith("king") and abs(dst_col - src_col) == 2:
        # 1. Move the King
        board[dst_row][dst_col] = piece_to_move
        board[src_row][src_col] = ""

        # 2. Move the Rook
        if dst_col == 6: # Kingside (e->g, move h->f)
            board[src_row][5] = board[src_row][7]
            board[src_row][7] = ""
            has_moved[f"{current_turn}_rook_ks"] = True
        elif dst_col == 2: # Queenside (e->c, move a->d)
            board[src_row][3] = board[src_row][0]
            board[src_row][0] = ""
            has_moved[f"{current_turn}_rook_qs"] = True
        
        # 3. Update the 'has_moved' status for the King
        has_moved[f"{current_turn}_king"] = True
        return True
    # --- END CASTLING EXECUTION ---
    
    # Standard Move Execution
    board[dst_row][dst_col] = piece_to_move
    board[src_row][src_col] = ""
    
    # --- UPDATE 'HAS_MOVED' STATUS FOR KING/ROOK ---
    color = current_turn
    if piece_to_move.endswith("king"):
        has_moved[f"{color}_king"] = True
    elif piece_to_move.endswith("rook"):
        if src_col == 7: # Kingside Rook
            has_moved[f"{color}_rook_ks"] = True
        elif src_col == 0: # Queenside Rook
            has_moved[f"{color}_rook_qs"] = True
    # ------------------------------------------------

    # Pawn Promotion Check
    if piece_to_move.endswith("pawn") and (dst_row == 0 or dst_row == 7):
        board[dst_row][dst_col] = f"{current_turn}_queen"
        print("Pawn promoted to Queen! ♕")
            
    return True

def print_board(board):
    print("\n    a   b   c   d   e   f   g   h")
    print("  +---+---+---+---+---+---+---+---+")
    for i, row in enumerate(board):
        print(f"{8 - i} | {' | '.join(piece_symbols.get(p, ' ') for p in row)} |")
        print("  +---+---+---+---+---+---+---+---+")

current_turn = "w"
while True:
    print_board(board)
    opponent_turn = "b" if current_turn == "w" else "w"
    
    # Check for game over conditions
    legal_moves = get_all_legal_moves(board, current_turn)
    if not legal_moves:
        if is_in_check(board, current_turn):
            print(f"*** CHECKMATE! {opponent_turn.upper()} wins! ***")
        else:
            print("*** STALEMATE! It's a draw. ***")
        break
        
    if is_in_check(board, current_turn):
        print("\n*** You are in CHECK! ***")
        
    print(f"\nIt's {current_turn.upper()}'s turn.")
    move = input("Enter your move (e.g., e2 e4, or e1 g1 for Castling) or 'exit' to quit: ").strip()
    
    if move.lower() == "exit":
        print("Thanks for playing!")
        break
        
    if make_move(board, move, current_turn):
        current_turn = opponent_turn
