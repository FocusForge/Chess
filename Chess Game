# Initial board setup
board = [
    ["b_rook", "b_knight", "b_bishop", "b_queen", "b_king", "b_bishop", "b_knight", "b_rook"],
    ["b_pawn"] * 8,
    [""] * 8,
    [""] * 8,
    [""] * 8,
    [""] * 8,
    ["w_pawn"] * 8,
    ["w_rook", "w_knight", "w_bishop", "w_queen", "w_king", "w_bishop", "w_knight", "w_rook"],
]

# Piece symbols for display
piece_symbols = {
    "b_pawn": "♟", "b_rook": "♜", "b_knight": "♞", "b_bishop": "♝", "b_queen": "♛", "b_king": "♚",
    "w_pawn": "♙", "w_rook": "♖", "w_knight": "♘", "w_bishop": "♗", "w_queen": "♕", "w_king": "♔"
}

# Convert algebraic notation (e.g., "e2") to board indices
def algebraic_to_index(pos):
    col = ord(pos[0].lower()) - ord('a')       # 'a' → 0, ..., 'h' → 7
    row = 8 - int(pos[1])                      # '1' → 7, ..., '8' → 0
    return row, col

# Validate pawn movement (forward only, one or two squares from starting position)
def is_valid_pawn_move(piece, src_row, src_col, dst_row, dst_col, board):
    color = piece[0]
    direction = -1 if color == "w" else 1  # White moves up (-1), Black moves down (+1)
    start_row = 6 if color == "w" else 1
    
    # --- 1. Diagonal Capture ---
    # The move must be one square forward in the correct direction.
    if dst_row == src_row + direction:
        # The move must be one square to the left or right.
        if dst_col == src_col - 1 or dst_col == src_col + 1:
            target_piece = board[dst_row][dst_col]
            # There must be an opponent's piece to capture.
            if target_piece != "" and not target_piece.startswith(color):
                return True

    # --- 2. Forward Movement ---
    # The destination square must be empty for any forward move.
    if board[dst_row][dst_col] == "":
        # Standard one-square move
        if dst_col == src_col and dst_row == src_row + direction:
            return True
        # Initial two-square move
        if (dst_col == src_col and src_row == start_row and
                dst_row == src_row + 2 * direction):
            # The path must be clear (the square in between must be empty).
            if board[src_row + direction][src_col] == "":
                return True

    # If none of the above conditions are met, the move is invalid.
    return False

# Move a piece from source to destination, enforcing turn rules and pawn validation
def make_move(board, move, current_turn):
    try:
        src, dst = move.strip().split()
        src_row, src_col = algebraic_to_index(src)
        dst_row, dst_col = algebraic_to_index(dst)

        piece = board[src_row][src_col]
        if piece == "":
            print(f"No piece at {src}")
            return False

        if not piece.startswith(current_turn):
            print(f"It's {current_turn.upper()}'s turn. You can't move {piece}.")
            return False

        target_piece = board[dst_row][dst_col]
        if target_piece != "" and target_piece.startswith(current_turn):
            print("You can't capture your own piece.")
            return False

        # Validate pawn movement
        if piece.endswith("pawn"):
            if not is_valid_pawn_move(piece, src_row, src_col, dst_row, dst_col, board):
                print("Invalid pawn move.")
                return False

        board[src_row][src_col] = ""
        board[dst_row][dst_col] = piece
        return True
    except Exception as e:
        print("Invalid move format or out-of-bounds:", e)
        return False

# Print the board with ranks and files
def print_board(board):
    print("    a   b   c   d   e   f   g   h")
    print("  " + "-" * 33)
    for i, row in enumerate(board, start=1):
        print(f"{8 - i + 1} | " + " | ".join(piece_symbols.get(piece, " ") for piece in row) + " |")
        print("  " + "-" * 33)

# Game loop for user input
current_turn = "w"  # 'w' for white, 'b' for black

while True:
    print_board(board)
    print(f"{current_turn.upper()}'s turn")
    move = input("Enter your move (e.g., e2 e4) or 'exit' to quit: ").strip()
    if move.lower() == "exit":
        print("Thanks for playing!")
        break
    if make_move(board, move, current_turn):
        current_turn = "b" if current_turn == "w" else "w"
