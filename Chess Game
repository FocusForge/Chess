# Initial board setup
board = [
    ["b_rook", "b_knight", "b_bishop", "b_queen", "b_king", "b_bishop", "b_knight", "b_rook"],
    ["b_pawn"] * 8,
    [""] * 8,
    [""] * 8,
    [""] * 8,
    [""] * 8,
    ["w_pawn"] * 8,
    ["w_rook", "w_knight", "w_bishop", "w_queen", "w_king", "w_bishop", "w_knight", "w_rook"],
]

# Piece symbols for display
piece_symbols = {
    "b_pawn": "♟", "b_rook": "♜", "b_knight": "♞", "b_bishop": "♝", "b_queen": "♛", "b_king": "♚",
    "w_pawn": "♙", "w_rook": "♖", "w_knight": "♘", "w_bishop": "♗", "w_queen": "♕", "w_king": "♔"
}

# Convert algebraic notation (e.g., "e2") to board indices
def algebraic_to_index(pos):
    col = ord(pos[0].lower()) - ord('a')       # 'a' → 0, ..., 'h' → 7
    row = 8 - int(pos[1])                      # '1' → 7, ..., '8' → 0
    return row, col

# Validate pawn movement (forward only, one or two squares from starting position)
def is_valid_pawn_move(piece, src_row, src_col, dst_row, dst_col, board):
    direction = -1 if piece.startswith("w") else 1  # white moves up, black moves down
    start_row = 6 if piece.startswith("w") else 1

    # Destination must be empty for now (no captures yet)
    if board[dst_row][dst_col] != "":
        return False

    # Move forward one square
    if dst_col == src_col and dst_row == src_row + direction:
        return True
    # Move forward two squares from starting position
    if dst_col == src_col and src_row == start_row and dst_row == src_row + 2 * direction:
        return True
    return False

# Move a piece from source to destination, enforcing turn rules and pawn validation
def make_move(board, move, current_turn):
    try:
        src, dst = move.strip().split()
        src_row, src_col = algebraic_to_index(src)
        dst_row, dst_col = algebraic_to_index(dst)

        piece = board[src_row][src_col]
        if piece == "":
            print(f"No piece at {src}")
            return False

        if not piece.startswith(current_turn):
            print(f"It's {current_turn.upper()}'s turn. You can't move {piece}.")
            return False

        target_piece = board[dst_row][dst_col]
        if target_piece != "" and target_piece.startswith(current_turn):
            print("You can't capture your own piece.")
            return False

        # Validate pawn movement
        if piece.endswith("pawn"):
            if not is_valid_pawn_move(piece, src_row, src_col, dst_row, dst_col, board):
                print("Invalid pawn move.")
                return False

        board[src_row][src_col] = ""
        board[dst_row][dst_col] = piece
        return True
    except Exception as e:
        print("Invalid move format or out-of-bounds:", e)
        return False

# Print the board with ranks and files
def print_board(board):
    print("    a   b   c   d   e   f   g   h")
    print("  " + "-" * 33)
    for i, row in enumerate(board, start=1):
        print(f"{8 - i + 1} | " + " | ".join(piece_symbols.get(piece, " ") for piece in row) + " |")
        print("  " + "-" * 33)

# Game loop for user input
current_turn = "w"  # 'w' for white, 'b' for black

while True:
    print_board(board)
    print(f"{current_turn.upper()}'s turn")
    move = input("Enter your move (e.g., e2 e4) or 'exit' to quit: ").strip()
    if move.lower() == "exit":
        print("Thanks for playing!")
        break
    if make_move(board, move, current_turn):
        current_turn = "b" if current_turn == "w" else "w"
